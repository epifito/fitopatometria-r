[
  {
    "objectID": "index.html#objetivos",
    "href": "index.html#objetivos",
    "title": "Fitopatometria |> R",
    "section": "Objetivos",
    "text": "Objetivos\nFamiliarizar al alumnado con herramientas (paquetes) del software R para manipular datos fitopatométricos."
  },
  {
    "objectID": "index.html#destinatarios",
    "href": "index.html#destinatarios",
    "title": "Fitopatometria |> R",
    "section": "Destinatarios",
    "text": "Destinatarios\nAgrónomos, Biólogos, Biotecnologos, y áreas afines a la fitopatología, con conocimientos básicos sobre R."
  },
  {
    "objectID": "index.html#uso",
    "href": "index.html#uso",
    "title": "Fitopatometria |> R",
    "section": "Uso",
    "text": "Uso\nEste manual web es un compendio de códigos que se utilizaran a lo largo del curso. Se sugiere tener descargados los mismos previamente a la clase para poder ir reproduciendo simultaneamente."
  },
  {
    "objectID": "1-metricas.html",
    "href": "1-metricas.html",
    "title": "1  Métricas básicas",
    "section": "",
    "text": "# Setup\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyverse, rio)"
  },
  {
    "objectID": "1-metricas.html#tipos-de-variables",
    "href": "1-metricas.html#tipos-de-variables",
    "title": "1  Métricas básicas",
    "section": "1.1 Tipos de variables",
    "text": "1.1 Tipos de variables\n\n# obtener todos el mismo set de numeros aleatorios \nset.seed(0)\nn=100\n\nEmpecemos simulando datos de incidencia\n\n# nivel de individuo \nbinomial1 <- rbinom(\n  n=n,      # number of observations: sample size \n  size=1,   # number of trials  \n  p=0.3     # probability of success\n)\nbinomial1\nhist(binomial1)\nabline(v=mean(binomial1), col=\"red\")\n\nAhora con submuestreo\n\nbinomial2 <- rbinom(\n  n=n,      # number of observations: sample size \n  size=10,  # number of trials: sub-sample \n  p=0.3     # probability of success\n)\nbinomial2\nhist(binomial2)\nrug(binomial2)\n\nabline(v=mean(binomial2), col=\"red\")  \n\ninc <- binomial2/10\n\n# Media poblacional = np \n10*0.3\n\n# Varianza = np(1-p)\n10*0.3*0.7\nsqrt(10*0.3*0.7)\n\nDisribución beta para proporciones, limitada entre 0 y 1:\n\nIncidencia (o prevalencia) de la enfermedad a nivel de muestra o población: proporción de individuos enfermos.\nSeveridad: expresada como proporción del área del órgano afectado.\n\n\nbeta1.5 <- rbeta(n = n, shape1 = 1, shape2 = 8)\nbeta5.1 <- rbeta(n = n, shape1 = 5, shape2 = 1)\n\nhist(beta1.5)\nrug(beta1.5)\nabline(v=mean(beta1.5), col=\"red\")\nhist(beta5.1)\nrug(beta5.1)\nabline(v=mean(beta5.1), col=\"red\")\n\nCompilamos en un data frame / tibble …\n\ndis_data <- tibble(inc, sev_cond= beta1.5) %>% \n  rowid_to_column(\"sample_id\")\ndis_data\n\ndis_data %>% \n  mutate(\n    inc_percen = inc*100, \n    sev_percen = sev_cond*100, \n    sev_media = sev_percen*inc)\n\nVariables continuas reales. Ej. Tamaño de lesión, longitud de raiz, etc.\nGeneralmente se describen mediante la distribución normal. Sin embargo, esta incluye valores negativos. En este caso podemos simular datos con la distribución gamma, que no puede tomar valores negativos.\n\ntam_les <- rgamma(n = n, \n                shape = 10, # valor medio \n                scale = 1)\n\nhist(tam_les)\nrug(tam_les)\nabline(v=mean(tam_les), col=\"red\")\n\nEsclerotos de sclerotinia por capítulo de girasol o nemaotodes por g de raiz son ejemplos de variables de conteos (variables discretas positivas o enteros). Estos pueden ser representados por una distribución de Poisson.\n\nconteos <- rpois(n = n,\n                 lambda = 20 # media\n                 )\nhist(conteos)\nrug(conteos)\nabline(v=mean(conteos), col=\"red\")"
  },
  {
    "objectID": "1-metricas.html#manipulacion",
    "href": "1-metricas.html#manipulacion",
    "title": "1  Métricas básicas",
    "section": "1.2 Manipulacion",
    "text": "1.2 Manipulacion\nAhora veamos una manipulacion multi-nivel de un muestreo multi-regional e inter-anual. Para eso carguemos el dataset Olivo/bacteriosis\n\n# load(\"data/data.RData\")\nolivo <- rio::import(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/olivo.csv\")\nolivo %>% view() \n\n\ndataset formato “wide” (planilla de campo) con 30 columnas de sev por arbol individual [datos simulados]\n\n\nRe-estructuracion —\n\nPasamos de formato wide a long para hacer operaciones por grupos. Ojo: No siempre debe hacerse este paso aunque nos habilita a group_by()+ summarise() # le pedimos que apile las columnas conteniendo a las plantas 1 a 30 # el nombre de las columnas las apile en una columna llamada “tree” # la observaciones de severidad las apile en una columna llamada sev # el producto de este re-arreglo se llamará “oli_long”\n\nolivo %>%   \n  pivot_longer(cols = `1`:`30`, \n         names_to = \"tree\",\n         values_to = \"sev\") -> oli_long \n\nChequeamos cuántos árboles fueron evaluados en cada año/región/lote:\n\noli_long\n\nChequeamos cuantos arboles se evaluaron por campo\n\noli_long %>%  \n  group_by(year, loc, farm) %>% \n  summarise(n= sum(!is.na(sev))) %>%  \n  pivot_wider(names_from=year, \n              values_from = n)\n\nImprimimos los 30 árboles de un mismo lote\n\noli_long %>%  \n  arrange(loc, year) %>%  \n  print(n=30)\n\n\nIncidencia\n\n(nivel lote - evolución interanual)\nProbamos el artilugio matemático que nos permitirá calcular la proporción de árboles enfermos\n\nmuestra1 <- c(0,1)\nmean(muestra1)\n\n\nmuestra2 <- c(0,0,0,0,1)\nmean(muestra2)\n\n\nmuestra3 <- c(1,1,1,1,1,1,1,1,0,0)\nmean(muestra3)\n\nAhora si, aplicaremos el artilugio a nuestros datos.\nTip: pueden ir seleccionando por lineas para ir probando el codigo antes de ejecutarlo por completo (seleccionar hasta antes de cada pipe, sino quedará abierta la sentencia)\n\n oli_long %>% \n  mutate(diseased = sev>0) %>%  \n  group_by(year, loc, farm) %>% \n  summarise(inc = mean(diseased, na.rm=TRUE)*100) %>%  \n  ungroup %>%  \n  arrange(loc, year) -> oli_inc \n\nDamos print a “oli_inc”\n\noli_inc\n\nGraficamos oli_inc (una de las posibilidades)\n\noli_inc %>%  \n  ggplot()+\n  # aes(x=factor(year), y=inc) +\n  aes(x=factor(year), y=inc, color=factor(farm)) +\n  geom_point() +\n  # geom_line() +\n  geom_line(aes(group=farm)) +\n  facet_grid(. ~ loc)\n\n\nPrevalencia\n\nNivel región - evolución interanual\n\noli_inc %>% \n  mutate(diseased_farm = inc>0) %>%  \n  group_by(year, loc) %>% \n  summarise(prev = mean(diseased_farm, na.rm=TRUE)*100) %>%  \n  ungroup %>%  \n  arrange(loc,year) -> oli_prev\n\n\noli_prev\n\nPlot de oli_prev\n\noli_prev %>%  \n  ggplot()+\n  aes(x=factor(year), y=prev, color=factor(loc)) +\n  geom_point() +\n  geom_line(aes(group=loc))\n\n\nSeveridad\n\nCalculamos ambas severidades vistas en la introducción teórica\nNOTA: en el teórico la sev_cond daba “NaN” en aquellos casos en que todos los arboles tenian sev=0, y en el filtrado sev[which(sev > 0)] el vector quedaba vacío.\n\noli_long %>%  \n  group_by(year, loc, farm) %>% \n  summarise(\n    sev_media = mean(sev, na.rm=TRUE), \n    sev_cond =mean(sev[which(sev > 0)])) %>%  \n  ungroup %>%  \n  mutate_all(~replace(., is.nan(.), 0)) %>%  \n  arrange(loc, year) -> oli_sev\noli_sev\n\nPrint oli_sev\n\noli_sev\n\nPlot oli_sev\n\nAprovechamos a usar una función muy eficiente que puede resultar una gran aliada en nuestro trabajo cotidiano: stat_summary()\n\n\noli_sev %>%  \n  ggplot()+\n  aes(x=loc, y =sev_media)+\n  geom_point(alpha=.3)+\n  facet_wrap(\"year\")+ \n  stat_summary(fun = mean, geom = \"crossbar\", col=\"blue\")+\n  stat_summary(aes(label=..y.. %>%  round(1)), \n               fun=mean, \n               geom=\"text\", size=4, vjust = -0.5)  +\n  scale_x_discrete(guide = guide_axis(n.dodge = 2))"
  },
  {
    "objectID": "2-metricas_comp.html",
    "href": "2-metricas_comp.html",
    "title": "2  Métricas compuestas",
    "section": "",
    "text": "# if (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyverse, epifitter, emmeans, performance, ggResidpanel, multcomp, multcompView)\ntheme_set(theme_light())"
  },
  {
    "objectID": "2-metricas_comp.html#auc",
    "href": "2-metricas_comp.html#auc",
    "title": "2  Métricas compuestas",
    "section": "2.1 AUC",
    "text": "2.1 AUC\nArea bajo la curva de progreso de la enfermedad\nReproducción de: APS Stripe rust\n\nepi <- tibble(\n  time = c(1,2,3,4), \n  dis = c(1,2,3,10))\n\n\nepi %>%  \n  ggplot()+\n  aes(x=time, y = dis)+\n  geom_point()+\n  geom_line()\n\nArea bajo la curva del progreso de la enfermedad (ABC) - Absoluta\n\nabc_1  <- with(epi, \n                 AUDPC(time = time, \n                  y = dis, \n                  y_proportion = FALSE, \n                  type = \"absolute\"))  \nabc_1\n\nABC standarizada\n\nsabc1 <- abc_1/(4-1)\nsabc1\n\nAplicación a un caso real\nReproducción de: APS Stripe rust\n\n## Set up vector for Madras AUDPC Chart\ndat <- tibble(\n  dai = c(0,10,20,30,40,50,60,70,80,90,100), \n  sev_68 = c(0,0,0,0,3,20,50,80, 90, 100, 100), \n  sev_69 = c( 0,0,0,0,0,0,0,3,6,30,70)\n)\ndat\n\n\ndat %>%  \n  ggplot()+\n  aes(x = dai) +\n  geom_line(aes(y = sev_68), col=\"red\")+\n  geom_line(aes(y = sev_69), col=\"blue\")\n\n\n# Epidemia de 1968\nwith(dat, \n     AUDPC(time = dai, \n      y = sev_68, \n      y_proportion = FALSE, \n      type = \"absolute\"))\n\n\n# Epidemia de 1969\nwith(dat, \n     AUDPC(time = dai, \n      y = sev_69, \n      y_proportion = FALSE, \n      type = \"absolute\"))\n\n\n# un poco de coding\ndat %>%  \n  pivot_longer(\n    cols= c(sev_68, sev_69), \n    names_to = \"epidemia\", \n    values_to = \"sev\", \n    names_prefix = \"sev_\")-> dat_long\n\n\ndat_long %>%\n  ggplot()+\n  aes(x = dai, y = sev, col=epidemia) +\n  geom_line()\n\n\ndat_long %>%  \n  group_by(epidemia) %>%  \n  summarise(abc=AUDPC(time = dai, \n                        y = sev, \n                        y_proportion = FALSE, \n                        type = \"absolute\"))"
  },
  {
    "objectID": "2-metricas_comp.html#dsi",
    "href": "2-metricas_comp.html#dsi",
    "title": "2  Métricas compuestas",
    "section": "2.2 DSI",
    "text": "2.2 DSI\n\n# poroto  <-  rio::import(\"data/poroto.csv\")\nporoto <- read.csv(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/poroto.csv\")\n\nDisease severity index (Indice de severidad)\n\nPoroto/sclerotinia\n\nDataset de formato wide, que incluye 3 variables descriptivas y 4 variables respuesta.\n\nporoto %>% \n  mutate(diseased = class_1 + class_2 + class_3 + class_4)  %>% \n  mutate(inc_p = diseased/n) %>% \n  # mutate(dsi_eq1 = (1*class_1+2*class_2+3*class_3+4*class_4)/(n*4) *100) %>% \n  # mutate(dsi_eq2 = (1*class_1+2*class_2+3*class_3+4*class_4)/n) %>% \n  mutate(dsi = (.13*class_1 +.375*class_2 + .625*class_3 + .875*class_4)/n*100) %>%   \n  mutate(dsi_p = dsi/100) %>% \n  mutate_at(vars(trt, rep), as.factor) -> poroto_dsi\nporoto_dsi\n\n\nporoto_dsi %>%  \n  ggplot() + \n  aes(x=trt, y =dsi) + \n  geom_point(alpha=.3)\n\nModel fitting\n\nmod1 <- lm(dsi ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod1, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod1)\ncheck_normality(mod1)\ncld(emmeans(mod1, ~ trt, type = \"response\"))\n\n\nmod2 <- lm(sqrt(dsi) ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod2, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod2)\ncheck_normality(mod2)\ncld(emmeans(mod2, ~ trt, type = \"response\"))\n\n\nasin_tran <- make.tran(\"asin.sqrt\", 100)\nmod3 <- with(asin_tran,\n            lm(linkfun(dsi) ~ trt, data = poroto_dsi)\n            )\n\n\nresid_panel(mod3, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod3)\ncheck_normality(mod3)\ncld(emmeans(mod3, ~ trt, type = \"response\"))\n\n\nmod4 = lm(log(dsi_p/(1-dsi_p)) ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod4, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod4)\ncheck_normality(mod4)\ncld(emmeans(mod4, ~trt, \n        tran = \"logit\", \n        type = \"response\"))\n\n\ncompare_performance(mod1, mod2, mod3, mod4)"
  },
  {
    "objectID": "2-metricas_comp.html#enfermedades-que-inducen-senescencia",
    "href": "2-metricas_comp.html#enfermedades-que-inducen-senescencia",
    "title": "2  Métricas compuestas",
    "section": "2.3 Enfermedades que inducen senescencia",
    "text": "2.3 Enfermedades que inducen senescencia\nEnsayo de fungicidas en cebada (trt=3). DBCA con 4 rep. Evaluaciones de sev media a los 0, 9, 20 y 29 dias desde aplicado. Estimacion de AF activa (lo que no es senescencia) La senescencia no cuenta para ninguna enfermedad, ya que es imposible distinguir su causa.\n\ncebada_raw <- read.csv(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/cebada_redu.csv\")\n\nHacemos un cebada long solo con fines graficos, entonces no creamos cebada_long.\n\ncebada_long <- cebada_raw %>% \n  pivot_longer(\n    cols = c(\"verdor\", \"e1_sev\", \"e2_sev\"), \n    names_to = \"var\", \n    values_to = \"val\") %>% \n  mutate(var = factor(var),\n         var = fct_relevel(var, \"verdor\")) \n\ncebada_long %>% \n  ggplot()+\n  aes(x=dias, y=val, col = var)+\n  facet_wrap(\"trt\")+\n  geom_point(alpha=0.3) +\n  stat_summary(fun=mean, geom=\"line\", \n               size=0.7, alpha=.5,  \n               aes(col=var, group=var)) +\n  scale_color_manual(\n    labels = c(\"AF\",  \"Sev mancha en red (%)\", \"Sev escaldadura (%)\"),\n    values = c(\"green\", \"red\", \"blue\")\n  ) +\n  theme_bw()+ \n  labs(title = \"Evolución área foliar\",\n       y = \"%\", x = \"Días desde aplicado\", \n       col = \"\")\n\nAhora calculamos el AF sana (%), restando al AF activa, la severidad media de mancha en red y escaldadura.\n\ncebada <- cebada_raw %>% \n  mutate(af_sana = verdor - e1_sev - e2_sev) %>% \n  mutate(sev_tot = e1_sev + e2_sev) \ncebada\n\nFinalmente calculamos el AUC del AF sana (LAI)\n\ncebada %>% \n  group_by(trt, rep) %>%\n  summarize(auc = AUDPC(time = dias, \n                        y = af_sana, \n                        y_proportion = FALSE, \n                        type = \"absolute\")) -> cebada_auc\n\n\ncebada_auc <- cebada_auc %>% \n  mutate_at(vars(trt, rep), as.factor)\n\n\ncebada_auc %>% \n  ggplot()+\n  aes(y=auc, x=trt, col=rep)+\n  geom_point()"
  }
]