[
  {
    "objectID": "index.html#objetivos",
    "href": "index.html#objetivos",
    "title": "Fitopatometria |> R",
    "section": "Objetivos",
    "text": "Objetivos\nFamiliarizar al alumnado con herramientas (paquetes) del software R para manipular datos fitopatométricos."
  },
  {
    "objectID": "index.html#destinatarios",
    "href": "index.html#destinatarios",
    "title": "Fitopatometria |> R",
    "section": "Destinatarios",
    "text": "Destinatarios\nAgrónomos, Biólogos, Biotecnologos, y áreas afines a la fitopatología, con conocimientos básicos sobre R."
  },
  {
    "objectID": "index.html#uso",
    "href": "index.html#uso",
    "title": "Fitopatometria |> R",
    "section": "Uso",
    "text": "Uso\nEste manual web es un compendio de códigos que se utilizaran a lo largo del curso. Se sugiere tener descargados los mismos previamente a la clase para poder ir reproduciendo simultaneamente."
  },
  {
    "objectID": "1-metricas.html",
    "href": "1-metricas.html",
    "title": "1  Métricas básicas",
    "section": "",
    "text": "# Setup\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyverse, rio)"
  },
  {
    "objectID": "1-metricas.html#tipos-de-variables",
    "href": "1-metricas.html#tipos-de-variables",
    "title": "1  Métricas básicas",
    "section": "1.1 Tipos de variables",
    "text": "1.1 Tipos de variables\n\n# obtener todos el mismo set de numeros aleatorios \nset.seed(0)\nn=100\n\nEmpecemos simulando datos de incidencia\n\n# nivel de individuo \nbinomial1 <- rbinom(\n  n=n,      # number of observations: sample size \n  size=1,   # number of trials  \n  p=0.3     # probability of success\n)\nbinomial1\nhist(binomial1)\nabline(v=mean(binomial1), col=\"red\")\n\nAhora con submuestreo\n\nbinomial2 <- rbinom(\n  n=n,      # number of observations: sample size \n  size=10,  # number of trials: sub-sample \n  p=0.3     # probability of success\n)\nbinomial2\nhist(binomial2)\nrug(binomial2)\n\nabline(v=mean(binomial2), col=\"red\")  \n\ninc <- binomial2/10\n\n# Media poblacional = np \n10*0.3\n\n# Varianza = np(1-p)\n10*0.3*0.7\nsqrt(10*0.3*0.7)\n\nDisribución beta para proporciones, limitada entre 0 y 1:\n\nIncidencia (o prevalencia) de la enfermedad a nivel de muestra o población: proporción de individuos enfermos.\nSeveridad: expresada como proporción del área del órgano afectado.\n\n\nbeta1.5 <- rbeta(n = n, shape1 = 1, shape2 = 8)\nbeta5.1 <- rbeta(n = n, shape1 = 5, shape2 = 1)\n\nhist(beta1.5)\nrug(beta1.5)\nabline(v=mean(beta1.5), col=\"red\")\nhist(beta5.1)\nrug(beta5.1)\nabline(v=mean(beta5.1), col=\"red\")\n\nCompilamos en un data frame / tibble …\n\ndis_data <- tibble(inc, sev_cond= beta1.5) %>% \n  rowid_to_column(\"sample_id\")\ndis_data\n\ndis_data %>% \n  mutate(\n    inc_percen = inc*100, \n    sev_percen = sev_cond*100, \n    sev_media = sev_percen*inc)\n\nVariables continuas reales. Ej. Tamaño de lesión, longitud de raiz, etc.\nGeneralmente se describen mediante la distribución normal. Sin embargo, esta incluye valores negativos. En este caso podemos simular datos con la distribución gamma, que no puede tomar valores negativos.\n\ntam_les <- rgamma(n = n, \n                shape = 10, # valor medio \n                scale = 1)\n\nhist(tam_les)\nrug(tam_les)\nabline(v=mean(tam_les), col=\"red\")\n\nEsclerotos de sclerotinia por capítulo de girasol o nemaotodes por g de raiz son ejemplos de variables de conteos (variables discretas positivas o enteros). Estos pueden ser representados por una distribución de Poisson.\n\nconteos <- rpois(n = n,\n                 lambda = 20 # media\n                 )\nhist(conteos)\nrug(conteos)\nabline(v=mean(conteos), col=\"red\")"
  },
  {
    "objectID": "1-metricas.html#manipulacion",
    "href": "1-metricas.html#manipulacion",
    "title": "1  Métricas básicas",
    "section": "1.2 Manipulacion",
    "text": "1.2 Manipulacion\nAhora veamos una manipulacion multi-nivel de un muestreo multi-regional e inter-anual. Para eso carguemos el dataset Olivo/bacteriosis\n\n# load(\"data/data.RData\")\nolivo <- rio::import(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/olivo.csv\")\nolivo %>% view() \n\n\ndataset formato “wide” (planilla de campo) con 30 columnas de sev por arbol individual [datos simulados]\n\n\nRe-estructuracion —\n\nPasamos de formato wide a long para hacer operaciones por grupos. Ojo: No siempre debe hacerse este paso aunque nos habilita a group_by()+ summarise() # le pedimos que apile las columnas conteniendo a las plantas 1 a 30 # el nombre de las columnas las apile en una columna llamada “tree” # la observaciones de severidad las apile en una columna llamada sev # el producto de este re-arreglo se llamará “oli_long”\n\nolivo %>%   \n  pivot_longer(cols = `1`:`30`, \n         names_to = \"tree\",\n         values_to = \"sev\") -> oli_long \n\nChequeamos cuántos árboles fueron evaluados en cada año/región/lote:\n\noli_long\n\nChequeamos cuantos arboles se evaluaron por campo\n\noli_long %>%  \n  group_by(year, loc, farm) %>% \n  summarise(n= sum(!is.na(sev))) %>%  \n  pivot_wider(names_from=year, \n              values_from = n)\n\nImprimimos los 30 árboles de un mismo lote\n\noli_long %>%  \n  arrange(loc, year) %>%  \n  print(n=30)\n\n\nIncidencia\n\n(nivel lote - evolución interanual)\nProbamos el artilugio matemático que nos permitirá calcular la proporción de árboles enfermos\n\nmuestra1 <- c(0,1)\nmean(muestra1)\n\n\nmuestra2 <- c(0,0,0,0,1)\nmean(muestra2)\n\n\nmuestra3 <- c(1,1,1,1,1,1,1,1,0,0)\nmean(muestra3)\n\nAhora si, aplicaremos el artilugio a nuestros datos.\nTip: pueden ir seleccionando por lineas para ir probando el codigo antes de ejecutarlo por completo (seleccionar hasta antes de cada pipe, sino quedará abierta la sentencia)\n\n oli_long %>% \n  mutate(diseased = sev>0) %>%  \n  group_by(year, loc, farm) %>% \n  summarise(inc = mean(diseased, na.rm=TRUE)*100) %>%  \n  ungroup %>%  \n  arrange(loc, year) -> oli_inc \n\nDamos print a “oli_inc”\n\noli_inc\n\nGraficamos oli_inc (una de las posibilidades)\n\noli_inc %>%  \n  ggplot()+\n  # aes(x=factor(year), y=inc) +\n  aes(x=factor(year), y=inc, color=factor(farm)) +\n  geom_point() +\n  # geom_line() +\n  geom_line(aes(group=farm)) +\n  facet_grid(. ~ loc)\n\n\nPrevalencia\n\nNivel región - evolución interanual\n\noli_inc %>% \n  mutate(diseased_farm = inc>0) %>%  \n  group_by(year, loc) %>% \n  summarise(prev = mean(diseased_farm, na.rm=TRUE)*100) %>%  \n  ungroup %>%  \n  arrange(loc,year) -> oli_prev\n\n\noli_prev\n\nPlot de oli_prev\n\noli_prev %>%  \n  ggplot()+\n  aes(x=factor(year), y=prev, color=factor(loc)) +\n  geom_point() +\n  geom_line(aes(group=loc))\n\n\nSeveridad\n\nCalculamos ambas severidades vistas en la introducción teórica\nNOTA: en el teórico la sev_cond daba “NaN” en aquellos casos en que todos los arboles tenian sev=0, y en el filtrado sev[which(sev > 0)] el vector quedaba vacío.\n\noli_long %>%  \n  group_by(year, loc, farm) %>% \n  summarise(\n    sev_media = mean(sev, na.rm=TRUE), \n    sev_cond =mean(sev[which(sev > 0)])) %>%  \n  ungroup %>%  \n  mutate_all(~replace(., is.nan(.), 0)) %>%  \n  arrange(loc, year) -> oli_sev\noli_sev\n\nPrint oli_sev\n\noli_sev\n\nPlot oli_sev\n\nAprovechamos a usar una función muy eficiente que puede resultar una gran aliada en nuestro trabajo cotidiano: stat_summary()\n\n\noli_sev %>%  \n  ggplot()+\n  aes(x=loc, y =sev_media)+\n  geom_point(alpha=.3)+\n  facet_wrap(\"year\")+ \n  stat_summary(fun = mean, geom = \"crossbar\", col=\"blue\")+\n  stat_summary(aes(label=..y.. %>%  round(1)), \n               fun=mean, \n               geom=\"text\", size=4, vjust = -0.5)  +\n  scale_x_discrete(guide = guide_axis(n.dodge = 2))"
  },
  {
    "objectID": "2-metricas_comp.html",
    "href": "2-metricas_comp.html",
    "title": "2  Métricas compuestas",
    "section": "",
    "text": "# if (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(tidyverse, epifitter, emmeans, performance, ggResidpanel, multcomp, multcompView)\ntheme_set(theme_light())"
  },
  {
    "objectID": "2-metricas_comp.html#auc",
    "href": "2-metricas_comp.html#auc",
    "title": "2  Métricas compuestas",
    "section": "2.1 AUC",
    "text": "2.1 AUC\nArea bajo la curva de progreso de la enfermedad\nReproducción de: APS-AUDPC\n\nepi <- tibble(\n  time = c(1,2,3,4), \n  dis = c(1,2,3,10))\n\n\nepi %>%  \n  ggplot()+\n  aes(x=time, y = dis)+\n  geom_point()+\n  geom_line()\n\nArea bajo la curva del progreso de la enfermedad (ABC) - Absoluta\n\nabc_1  <- with(epi, \n                 AUDPC(time = time, \n                  y = dis, \n                  y_proportion = FALSE, \n                  type = \"absolute\"))  \nabc_1\n\nABC standarizada\n\nsabc1 <- abc_1/(4-1)\nsabc1\n\nAplicación a un caso real\nReproducción de: APS Stripe rust\n\n## Set up vector for Madras AUDPC Chart\ndat <- tibble(\n  dai = c(0,10,20,30,40,50,60,70,80,90,100), \n  sev_68 = c(0,0,0,0,3,20,50,80, 90, 100, 100), \n  sev_69 = c( 0,0,0,0,0,0,0,3,6,30,70)\n)\ndat\n\n\ndat %>%  \n  ggplot()+\n  aes(x = dai) +\n  geom_line(aes(y = sev_68), col=\"red\")+\n  geom_line(aes(y = sev_69), col=\"blue\")\n\n\n# Epidemia de 1968\nwith(dat, \n     AUDPC(time = dai, \n      y = sev_68, \n      y_proportion = FALSE, \n      type = \"absolute\"))\n\n\n# Epidemia de 1969\nwith(dat, \n     AUDPC(time = dai, \n      y = sev_69, \n      y_proportion = FALSE, \n      type = \"absolute\"))\n\n\n# un poco de coding\ndat %>%  \n  pivot_longer(\n    cols= c(sev_68, sev_69), \n    names_to = \"epidemia\", \n    values_to = \"sev\", \n    names_prefix = \"sev_\")-> dat_long\n\n\ndat_long %>%\n  ggplot()+\n  aes(x = dai, y = sev, col=epidemia) +\n  geom_line()\n\n\ndat_long %>%  \n  group_by(epidemia) %>%  \n  summarise(abc=AUDPC(time = dai, \n                        y = sev, \n                        y_proportion = FALSE, \n                        type = \"absolute\"))"
  },
  {
    "objectID": "2-metricas_comp.html#dsi",
    "href": "2-metricas_comp.html#dsi",
    "title": "2  Métricas compuestas",
    "section": "2.2 DSI",
    "text": "2.2 DSI\n\n# poroto  <-  rio::import(\"data/poroto.csv\")\nporoto <- read.csv(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/poroto.csv\")\n\nDisease severity index (Indice de severidad)\n\nPoroto/sclerotinia\n\nDataset de formato wide, que incluye 3 variables descriptivas y 4 variables respuesta.\n\nporoto %>% \n  mutate(diseased = class_1 + class_2 + class_3 + class_4)  %>% \n  mutate(inc_p = diseased/n) %>% \n  # mutate(dsi_eq1 = (1*class_1+2*class_2+3*class_3+4*class_4)/(n*4) *100) %>% \n  # mutate(dsi_eq2 = (1*class_1+2*class_2+3*class_3+4*class_4)/n) %>% \n  mutate(dsi = (.13*class_1 +.375*class_2 + .625*class_3 + .875*class_4)/n*100) %>%   \n  mutate(dsi_p = dsi/100) %>% \n  mutate_at(vars(trt, rep), as.factor) -> poroto_dsi\nporoto_dsi\n\n\nporoto_dsi %>%  \n  ggplot() + \n  aes(x=trt, y =dsi) + \n  geom_point(alpha=.3)\n\nModel fitting\n\nmod1 <- lm(dsi ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod1, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod1)\ncheck_normality(mod1)\ncld(emmeans(mod1, ~ trt, type = \"response\"))\n\n\nmod2 <- lm(sqrt(dsi) ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod2, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod2)\ncheck_normality(mod2)\ncld(emmeans(mod2, ~ trt, type = \"response\"))\n\n\nasin_tran <- make.tran(\"asin.sqrt\", 100)\nmod3 <- with(asin_tran,\n            lm(linkfun(dsi) ~ trt, data = poroto_dsi)\n            )\n\n\nresid_panel(mod3, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod3)\ncheck_normality(mod3)\ncld(emmeans(mod3, ~ trt, type = \"response\"))\n\n\nmod4 = lm(log(dsi_p/(1-dsi_p)) ~ trt, data = poroto_dsi)\n\n\nresid_panel(mod4, plots = c(\"resid\", \"qq\"))\ncheck_heteroscedasticity(mod4)\ncheck_normality(mod4)\ncld(emmeans(mod4, ~trt, \n        tran = \"logit\", \n        type = \"response\"))\n\n\ncompare_performance(mod1, mod2, mod3, mod4)"
  },
  {
    "objectID": "2-metricas_comp.html#enfermedades-que-inducen-senescencia",
    "href": "2-metricas_comp.html#enfermedades-que-inducen-senescencia",
    "title": "2  Métricas compuestas",
    "section": "2.3 Enfermedades que inducen senescencia",
    "text": "2.3 Enfermedades que inducen senescencia\nEnsayo de fungicidas en cebada (trt=3). DBCA con 4 rep. Evaluaciones de sev media a los 0, 9, 20 y 29 dias desde aplicado. Estimacion de AF activa (lo que no es senescencia) La senescencia no cuenta para ninguna enfermedad, ya que es imposible distinguir su causa.\n\ncebada_raw <- read.csv(\"https://raw.githubusercontent.com/epifito/fitopatometria-r/main/data/cebada_redu.csv\")\n\nHacemos un cebada long solo con fines graficos, entonces no creamos cebada_long.\n\ncebada_long <- cebada_raw %>% \n  pivot_longer(\n    cols = c(\"verdor\", \"e1_sev\", \"e2_sev\"), \n    names_to = \"var\", \n    values_to = \"val\") %>% \n  mutate(var = factor(var),\n         var = fct_relevel(var, \"verdor\")) \n\ncebada_long %>% \n  ggplot()+\n  aes(x=dias, y=val, col = var)+\n  facet_wrap(\"trt\")+\n  geom_point(alpha=0.3) +\n  stat_summary(fun=mean, geom=\"line\", \n               size=0.7, alpha=.5,  \n               aes(col=var, group=var)) +\n  scale_color_manual(\n    labels = c(\"AF\",  \"Sev mancha en red (%)\", \"Sev escaldadura (%)\"),\n    values = c(\"green\", \"red\", \"blue\")\n  ) +\n  theme_bw()+ \n  labs(title = \"Evolución área foliar\",\n       y = \"%\", x = \"Días desde aplicado\", \n       col = \"\")\n\nAhora calculamos el AF sana (%), restando al AF activa, la severidad media de mancha en red y escaldadura.\n\ncebada <- cebada_raw %>% \n  mutate(af_sana = verdor - e1_sev - e2_sev) %>% \n  mutate(sev_tot = e1_sev + e2_sev) \ncebada\n\nFinalmente calculamos el AUC del AF sana (LAI)\n\ncebada %>% \n  group_by(trt, rep) %>%\n  summarize(auc = AUDPC(time = dias, \n                        y = af_sana, \n                        y_proportion = FALSE, \n                        type = \"absolute\")) -> cebada_auc\n\n\ncebada_auc <- cebada_auc %>% \n  mutate_at(vars(trt, rep), as.factor)\n\n\ncebada_auc %>% \n  ggplot()+\n  aes(y=auc, x=trt, col=rep)+\n  geom_point()"
  },
  {
    "objectID": "3-glm_binomial.html",
    "href": "3-glm_binomial.html",
    "title": "3  GLM binomial",
    "section": "",
    "text": "Dist. Normal\n\n\nset.seed(1)\nx <- rnorm(n=100,    # sample size\n          mean=10,  # mean of sample\n          sd=3      # standard deviation of sample\n         )\nhead(x)\nmean(x)\nsd(x)\n\n# predictor linear\nmu = 3 + 2*x      \nplot(x, mu)\n\n# generamos el componente aleatorio con distribucion normal de los errores\n# set.seed(1)\ny  <- mu + rnorm(100, 0, 3)\n\nplot(x,y)\n\n\nLM - repaso\n\n\nmod1 <- lm(y~x)\nplot_model(mod1, type='pred', show.data=T, ci.lvl = NA)\nsummary(mod1)\n\nDe este modelo entendemos que cuando x=0, y=2.89 y por cada aumento unitario de x, y aumenta 1.99 unidades\ny = 2.89 + 1.99 * x\nAhora veamos el mismo ajuste usando “glm”\n\nmod1.1 <- glm(y~x, family = gaussian)\nplot_model(mod1.1, type='pred', show.data=T, ci.lvl = NA)\nsummary(mod1.1)\n\ny = 2.89 + 1.99 * x\nExactamente los mismos coeficientes que mod1\n\ngaussian()\nbinomial()\npoisson()\n\n\nDist. Binomial\n\nEntendamos la naturaleza binaria de la incidencia.\nImaginemos que estamos entrando en un campo de soja y queremos estimar la incidencia de una enfermedad foliar X\nUna estacion (unidad) de muestreo de tamaño 30\n\nset.seed(1)\n\nbin_1 <- rbinom(\n  1,        # numero de observaciones o simulaciones (estaciones de muestreo)\n  size=30,  # numero de ensayos (n) \n  p=0.1     # probabilidad de exito (p)\n)\nbin_1\nbin_1/30    # 1 valor de incidencia de estacion de muestreo\n\n# 0.066 -> 6,6% incidencia media del lote\n\n# gghist(bin_1, e=30*0.1, m = mean(bin_1))\n\n10 estaciones de muestreo de tamaño 30\n\nset.seed(1)\n\nbin_2 <- rbinom(\n  10,       # numero de observaciones\n  size=30,  # numero de ensayos (n) \n  p=0.1     # probabilidad de exito (p)\n)\nbin_2       # muestra compuesta de 10 estaciones de muestreo con n=30 \nbin_2/30    # 10 valores de incidencia de n=30\n\n# gghist(bin_2, e=30*0.1, m=mean(bin_2)) \n\nmean(bin_2/30) \n# 0.11 -> 11% incidencia media del lote\n\n100 estaciones de muestreo de tamaño 30\n\nset.seed(1)\nbin_3 <- rbinom(\n  100,    # numero de observaciones\n  size=30,  # numero de ensayos \n  p=0.1     # probabilidad de exito\n)\nbin_3\n\n# gghist(bin_3, e=30*0.1, m=mean(bin_3)) \nbin_3/30 # 100 valores de incidencia de n=30\nmean(bin_3/30) \n# 0.101 -> 10.1% incidencia media del lote\n\n\n# media = np \nmedia = 30*0.1\nmedia\n\n# varianza  = np(1−p) \nvarianza =  30*0.1*(1-0.1)\nvarianza\n\n# sd = sqrt(np(1−p)) \nsd =  sqrt(30*0.1*(1-0.1))\nsd\n# sd_field =  1.643168\n\nVariable aleatoria \\(X\\) que es distribuida \\(X∼binomial(n,p)\\) con media \\(μ = np\\) y varianza \\(σ2=np(1−p)\\), siendo \\(X\\) el conteo de eventos exitosos en \\(n\\) ensayos Bernoulli idénticos e independientes con probabilidad de éxito \\(p\\) constante."
  },
  {
    "objectID": "3-glm_binomial.html#dbca",
    "href": "3-glm_binomial.html#dbca",
    "title": "3  GLM binomial",
    "section": "3.2 DBCA",
    "text": "3.2 DBCA\n\nphom_raw <- import(\"https://raw.githubusercontent.com/juanchiem/glm_webinar/main/data/phomopsis.csv\") %>% tibble\n# phom_raw <- rio::import(\"data/phomopsis.csv\") %>% tibble \n\nEfecto de tratamientos de fungicidas sobre tizon foliar por Phomopsis en frutilla (Madden et al. 2002)\n\nPatógeno: Phomopsis obscurans\nDiseño en bloques completos aleatorizados (RCBD)\nCuatro bloques (bk, j = 1, …, 4)\nOcho tratamientos: control no tratado + 7 fungicidas (trt, i = 1, …, 8) aleatorizados dentro de cada bloque\nVariable respuesta (Y): Numero de foliolos enfermos\nn Tamaño de la muestra\nIncidencia por parcela = y/n\nAcondicionamiento\n\n\nphom_raw  \n\n# Factorizamos nuestros variebles independientes (predictoras) y calculamos la incidencia en proporcion \n\nphom_dat <- phom_raw %>% \n  mutate_at(vars(trt, bk), as.factor) %>% \n  mutate(inc=y/n) %>% \n  arrange(trt)\nphom_dat\n\n\nVisualización\n\n\nphom_dat %>% \n  ggplot() + \n  aes(x=trt, y = inc) + \n  geom_boxplot(alpha=.5, width = .2) + \n  geom_point(alpha=.7) + \n  labs(x=\"Tratamientos\", y=\"Incidencia (proporción)\")\n\n\nModelos mixtos\n\nEfecto fijo al tratamiento y aleatorio a los bloques\n\nLM\n\n\n# pacman::p_load(lmerTest)\nmod_phom_LM <- lmer(inc ~ trt + (1|bk), \n                    data=phom_dat)\nperformance::check_homogeneity(mod_phom_LM)\nperformance::check_normality(mod_phom_LM)\n\n\ncar::Anova(mod_phom_LM, type=\"III\")\nsummary(mod_phom_LM)\n\nPodriamos avanzar con el modelo, hacia la estimacion de medias predichas por el mismo\n{emmeans, multcomp}\n\nem_phom_LM <- emmeans(mod_phom_LM, ~ trt, type=\"response\")\nem_phom_LM\n# comparaciones multiples \nres_phom_LM <- cld(em_phom_LM, Letters = letters, alpha = .05, type = \"response\")\n\nknitr::kable(res_phom_LM)\n\nplot_model(mod_phom_LM, type='pred', show.data=T)\n\nInterpretacion de coeficientes:\nAhora que tenemos los predichos de cada tratamiento podemos interpretar los coeficientes.\nRecordemos que trt 1 es el nivel de referencia (orden arbitrario alfabético, se puede cambiar), y el resto de trat se suman a este para la estimacion de su media:\n\nknitr::kable(res_phom_LM)\nsummary(mod_phom_LM)\nc_t1 = 0.4366667\nc_t2 = 0.4366667 +(-0.15667)\nc_t2\nc_t3 = 0.4366667 +(-0.29000)\nc_t3\n\n\nGLM\n\n(Anecdotico)\n\nmod_phom_LM2 <- glmer(inc ~ trt + (1|bk),\n                      family = gaussian(\"identity\"),\n                      data=phom_dat)\nsummary(mod_phom_LM2)\nsummary(mod_phom_LM)\n\nOpción 1: variable original (éxitos y fracasos) agrupados\n\nmod_phom_GLM1 <- glmer(\n  cbind(y, n-y) ~ trt + (1|bk), # matriz de exitos y fracasos\n  family=\"binomial\",\n  data=phom_dat)\nsummary(mod_phom_GLM1)\n\nOpción 2: proporcion de exitos / total muestra (incidencia)\n\nmod_phom_GLM2 <- glmer(inc ~ trt + (1|bk), \n               family=\"binomial\", \n               weights = n, # pesos o tamaño de muestra\n               data=phom_dat)\nsummary(mod_phom_GLM2)\n\n\ntab_model(mod_phom_GLM1, mod_phom_GLM2)\n\n\nDiagnósticos\n\nhttps://stats.stackexchange.com/questions/185491/diagnostics-for-generalized-linear-mixed-models-specifically-residuals\n{DHARMa}\nhttps://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html#goodness-of-fit-tests-on-the-scaled-residuals\n\ntestOutliers(mod_phom_GLM2)\ntestDispersion(mod_phom_GLM2)\n\nMedias predichas por el modelo ajustado y comparaciones multiples\n\nem_phom_GLM <- emmeans(mod_phom_GLM2, ~ trt, type=\"response\")\nres_phom_GLM <- cld(em_phom_GLM, Letters = letters, alpha = .05, type = \"response\")\nknitr::kable(res_phom_GLM)\n\n\nInterpretacion de coeficientes\n\ntrt 1 es el nivel de referencia, y el resto de trat se suman a este para la estimacion de su media:\nPero ahora en escala de log ODDS\n\nsummary(mod_phom_GLM2)\nknitr::kable(res_phom_GLM)\n\nLO_t1 = -0.2585\np_t1 = 0.4357251\n\nodds_t1 = 0.4357251 / (1-0.4357251)\nodds_t1 \n\nlog(odds_t1)\nLO_t1\n# volver a slide 15\n\nResto de tratamientos\n\np_t2 = 0.2763751\nodds_t2 = 0.2763751 / (1-0.2763751)\n\nOR_t2_t1 = odds_t2/odds_t1\n\nOR_t2_t1 #  0.4946108\n\nlog(OR_t2_t1) # chequear con summary\nsummary(mod_phom_GLM2)\nlog(OR_t2_t1) # chequear con summary\n\n# similar al LM?\nlog(odds_t2) - log(odds_t1)\n\n\n# t2 directamente del summary\nexp(-0.7040)\nOR_t2_t1\ntab_model(mod_phom_GLM2)\n(1-0.4946029) * 100\n# 50.53971\n\n\nLa chance de un foliolo de frutilla presentar sintoma de phomopsis disminuye un 50% cuando se aplica el tratamiento 2 respecto al control sin tratar\n\n\nknitr::kable(res_phom_LM)\nknitr::kable(res_phom_GLM)\n\n• Los errores estándar estimados (SE) son todos incorrectos (por definición), deben ser funciones de la media para datos binomiales\n• Los SE incorrectos darán pruebas incorrectas de significación para los efectos del tratamiento y conducirán a conclusiones incorrectas"
  },
  {
    "objectID": "3-glm_binomial.html#reg.-logistica",
    "href": "3-glm_binomial.html#reg.-logistica",
    "title": "3  GLM binomial",
    "section": "3.3 Reg. Logistica",
    "text": "3.3 Reg. Logistica\n\nData maracuya:\ngeno: genotipos de maracuyá (Passiflora edulis) (A y B)\nbk: bloque (area homogenea dentro del campo que incluye hileras de genotipo A y B) - Efecto aleatorio\ndays: dias desde la inoculacion (DDI) con el virus CABMV (Cowpea aphid-borne mosaic virus)\nn_plants: nro de plantas evaluadas dentro de cada parcela\ndis_plants: plantas con sintomas del CABMV\ny = inc_prop (dis_plants/n_plants)\nplot: unidad experimental (parcelas=bloque:geno)\n\n\nraw <- rio::import(\"https://raw.githubusercontent.com/juanchiem/glm_webinar/main/data/maracuya.csv\") %>% tibble\n# raw <- rio::import(\"data/maracuya.csv\") %>% tibble\n\ndat <- raw %>%  \n  mutate_at(vars(geno, bk), as.factor) %>% \n  mutate(inc_prop=dis_plants/n_plants, \n         plot = interaction(bk,geno))  # %>% \n\ndat %>%\n    ggplot() +\n    aes(x=days, y=inc_prop, col=geno, shape=bk)+\n    geom_point()+\n    geom_line(aes(group=interaction(bk,geno))) \n\nFiltramos el dataset completo para subsets menores\n\n# solo una evaluación a los 60 dias \ndat60 <- dat %>% \n  filter(days %in% c(60))\n\n# solo una evaluación a los 90 dias \ndat90 <- dat %>% \n  filter(days %in% c(90))\n\n# Dos evaluaciones: a los 60 y 90 dias \ndat60_90 <- dat %>% \n  filter(days %in% c(60, 90)) # %>% \n  # mutate_at(vars(days), as.factor) \n\n\n3.3.1 Single-point assessment\n\n60 d\n\n\ndat60\ndat60 %>% \n  ggplot() + \n  aes(x=geno, y=inc_prop) + \n  geom_jitter(alpha=.5, width=.02)\n\n\n# mod1 <- glmer(\n#   cbind(dis_plants, n_plants-dis_plants) ~ geno + (1|bk), \n#   family=\"binomial\", \n#   data=dat60) \n\nmod1 <- glmer(\n  inc_prop ~ geno + (1|bk), # bloque como efecto aleatorio\n  weights=n_plants,         \n  family=\"binomial\", \n  data=dat60) \n\ncar::Anova(mod1)\nsummary(mod1)\n\n\ntab_model(mod1)\nplot_model(mod1, type='pred', show.data=T,   bpe.color =\"red\")\n\nOtro gran aliado es el paquete “emmeans” quien nos devuelve las estimaciones en proporcion ahorrandonos muchos calculos manuales\n\nem1 <- emmeans(mod1, ~ geno, type=\"response\")\nres1 <- cld(em1, Letters = letters, alpha = .05, type = \"response\")\nknitr::kable(res1)\n\nInterpretacion de coef y medidas de efecto\n\n# lo que nos da el emmeans\np_A = 0.1066667\np_B =  0.0933333\n\nodds_A = p_A/(1-p_A)\nodds_B = p_B/(1-p_B)\n\n# lo que nos da el tab_model\nOR_B_A = odds_B/odds_A\nOR_B_A\n\n# lo que nos da el summary \nlog_OR_B_A = log(OR_B_A)\nlog_OR_B_A  \nsummary(mod1)\n\n\n90 d\n\n\ndat90\n\ndat90 %>% \n  ggplot() + \n  aes(x=geno, y=inc_prop) + \n  geom_point()\n\n# mod1 <- glmer(\n#   cbind(dis_plants, n_plants-dis_plants) ~ geno + (1|bk), \n#   family=\"binomial\", \n#   data=dat60)\n\n\nmod2 <- glmer(\n  inc_prop ~ geno + (1|bk),\n  weights=n_plants,\n  family=\"binomial\", \n  data=dat90)\n\n# boundary (singular) fit: see help('isSingular') puede deberse al bajo numero de bk\n\n\ncar::Anova(mod2)\nsummary(mod2)\n\nVemos que ahora si, el geno tiene efecto significativo sobre la incidencia de la enfermedad\n\ntab_model(mod2)\n\npodemos decir que la chance de presentar la enfermedad del genotipo B es 71% (1 - 0.29 = 0.71 * 100) menor en relacion al geno A\n\nplot_model(mod2, type='pred', show.data=T)\n\n\nem2 <- emmeans(mod2, ~ geno, type=\"response\")\nres2 <- cld(em2, Letters = letters, alpha = .05, type = \"response\")\nknitr::kable(res2)\n\n\n\n3.3.2 Multiple-point assessment\nIncluyendo una interaccion\n\n60 y 90 d\n\n\ndat60_90\n\ndat60_90 %>% \n  ggplot() +\n  aes(x=days, y=inc_prop, col=geno, shape=bk)+\n  geom_point()\n\n\n# debido a las mediciones repetidas en el tiempo agregamos efecto aleatorio sobre la parcela\n\nmod3 <- glmer(inc_prop ~ geno * days + \n                (1|bk) + (1|bk:geno), \n              weights=n_plants,\n              family=\"binomial\",\n              data=dat60_90) \n\ncar::Anova(mod3)\n\n(anecdotico: days como factor con 2 niveles)\n\ncar::Anova(glmer(inc_prop ~ geno * factor(days) + \n                (1|bk) + (1|bk:geno), \n              weights=n_plants,\n              family=\"binomial\",\n              data=dat60_90))\n\nRemoviendo la interaccion, dejando como efectos simples geno y dias\n\nmod3.1 <- glmer(inc_prop ~ geno + days + \n                  (1|bk) + (1|bk:geno),\n              weights=n_plants,\n              family=\"binomial\",\n              data=dat60_90)\n\n\nanova(mod3, mod3.1, test = \"Chisq\")\nAIC(mod3, mod3.1)\n\nEl modelo conteniendo la interaccion (geno * days) es mejor (p=0.0231, AIC=58.34804)\n(anecdótico: asignacion de parcela explicitamente)\n\nmod3_ <- glmer(inc_prop ~ geno * days + \n                (1|bk) + (1|plot), \n              weights=n_plants,\n              family=\"binomial\",\n              data=dat60_90) \nAIC(mod3, mod3_)\n\n\nsummary(mod3)\n\nlog odds A = -5.33987 + 0.05358 days log odds B = (-5.33987 + 2.04105) + (0.0535-0.036) days\n\ntab_model(mod3)\n\ndays = 1.06 >> por cada dia acumulado desde la inoculacion el geno A tiene una chance de aumentar 1.06 veces la probabilidad de aparicion de sintomas (aumento de la incidencia) y es significativo (IC: 1.03–1.08, p= <0.001)\ngeno [B] * days = 0.96 >>> la chance de aumentar la incidencia por cada dia desde la inoculacion en el geno B es 4% menor respecto al geno A (IC: 0.93 – 0.99, p=0.023)\n\nplot_model(mod3, \n           terms = c(\"days\", \"geno\"), \n           type='pred', show.data=T)\n\nem3 <- emmeans(mod3, ~ geno|days, type=\"response\")\n\nres3 <- cld(em3, Letters = letters, alpha = .05, type = \"response\")\nknitr::kable(res3)\n\nconfirmamos lo visto anteriormente: - a los 60 dias no hubo diferencias en la incidencia del virus, pero si a los 90 ddi\n\n\n3.3.3 Serie full\n\nhead(dat)\ndat %>% \n  ggplot() +\n  aes(x=days, y=inc_prop, col=geno, shape=bk)+\n  geom_point()\n\n# debido a las mediciones repetidas en el tiempo agregamos efecto aleatorio sobre la parcela\n\nmod_serie <- glmer(inc_prop ~ geno * days + \n                     (1|bk) + (1|bk:geno),  \n                   weights=n_plants,\n                   family=\"binomial\",\n                   data=dat) \n\n\n# Sacamos el efecto del genotipo\nmod_serie0 <- glmer(inc_prop ~ days +  \n    (1|bk) + (1|bk:geno),\n              weights=n_plants,\n              family=\"binomial\",\n              data=dat) \n\nmod_serie1 <- glmer(inc_prop ~ days + geno +   \n    (1|bk) + (1|bk:geno),\n              weights=n_plants,\n              family=\"binomial\",\n              data=dat) \n\n\nSeleccion de modelo\n\n\nanova(mod_serie0, mod_serie1, mod_serie, test = \"Chisq\")\nAIC(mod_serie0, mod_serie1, mod_serie)\n\nmod_serie: df=6 y AIC=299.4276\nDiagnósticos\n\ntestOutliers(mod_serie)\ntestDispersion(mod_serie)\n\n\nsummary(mod_serie)\n\ntab_model(mod_serie)\nplot_model(mod_serie, \n           terms = c(\"days\", \"geno\"), \n           type='pred', show.data=T)\n\nPred. lineal geno A = -3.18 + 0.024 * days (dias significativo para el geno A, ya que conforme transcurren los dias la incidencia aumenta)\nPred. lineal geno B = (-3.275 + 0.147) + (0.025 + 0.99) * days\nInteraccion significativa: las curvas son diferentes, deben ajustarse una por genotipo\n\nPredicción\n\n{ggeffects}\nCurva completa\n\nggpredict(mod_serie, c( \"days\", \"geno\"))\n\nGenotipo A - intervalo 100 a 110 ddi\n\nggpredict(mod_serie, \n          terms = \"days [100:110]\", \n          condition = c(geno = c(\"A\")))\n\nAmbos genotipos para el DDI=100\n\nggpredict(mod_serie, \n          terms = \"geno\", \n          condition = c(days = \"100\"))\n\n\n\n\n\nMadden, L., Turechek, W., and Nita, M. 2002. Evaluation of generalized linear mixed models for analyzing disease incidence data obtained in designed experiments. Plant Disease. 86:316–325."
  },
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Referencias",
    "section": "",
    "text": "Madden, L., Turechek, W., and Nita, M. 2002. Evaluation of generalized\nlinear mixed models for analyzing disease incidence data obtained in\ndesigned experiments. Plant Disease. 86:316–325."
  }
]